generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  id            String     @id @default(auto()) @map("_id") @db.ObjectId
  email         String     @unique
  username      String     @unique
  password      String
  isAdmin       Boolean    @default(false)
  lastStaminaReset DateTime @default(now())
  staminaTransactions StaminaTransaction[]
  nftMints      NFTMint[]
  userScenes    UserScene[]
  gameState     GameState?
  subscription  Subscription?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
}

model StaminaTransaction {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  amount    Int      // Can be positive (gain) or negative (usage)
  reason    String   // "DAILY_RESET", "SCENE_GENERATION", "NFT_MINT", "REFUND", etc.
  metadata  Json?    // Additional context about the transaction
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}

model NFTMint {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenId   String
  metadata  Json
  txHash    String
  createdAt DateTime @default(now())
}

model Subscription {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @unique @db.ObjectId
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String   // "FREE", "PREMIUM", "UNLIMITED"
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model GameState {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  userId        String   @unique @db.ObjectId
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  progress      Json
  relationships Json
  choices       Json
  settings      Json
  lastSaved     DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Scene {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  sceneId       String   @unique
  character     String
  emotion       String
  text          String
  next          String?
  choices       Json?
  context       String?
  requiresAI    Boolean  @default(false)
  background    String?
  characterImage String?
  backgroundImage String?
  type          String   @default("dialogue")
  metadata      Json?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  userScenes    UserScene[]
}

model Character {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  characterId   String   @unique
  name          String
  personality   String
  background    String
  traits        String[]
  relationships Json?
  emotions      Json
  images        Json     // Store emotion -> image URL mappings
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Asset {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  type      String   // "background" or "character"
  name      String   // Identifier for the asset
  url       String   // URL to the image
  category  String?  // For backgrounds: category like "indoor", "outdoor", etc.
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([type, name])
}

model UserScene {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  sceneId   String   
  scene     Scene    @relation(fields: [sceneId], references: [sceneId])
  viewed    Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, sceneId])
}